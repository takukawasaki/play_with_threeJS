// Generated by CoffeeScript 1.9.1
var animate, camera, container, geometry, init, initCamera, initObject, initStats, material, mesh, onWindowResize, positions, render, renderer, scene, segments, start, stats;

positions = void 0;

container = void 0;

stats = void 0;

camera = void 0;

scene = void 0;

renderer = void 0;

mesh = void 0;

camera = void 0;

segments = void 0;

geometry = void 0;

material = void 0;

init = function() {
  container = document.createElement('div');
  scene = new THREE.Scene();
  segments = 1000;
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.gammaInput = true;
  renderer.gammaOutput = true;
  document.body.appendChild(container);
  container.appendChild(renderer.domElement);
};

initCamera = function() {
  camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.z = 1500;
};

initObject = function() {
  var colors, i, r, x, y, z;
  geometry = new THREE.BufferGeometry();
  material = new THREE.LineBasicMaterial({
    vertexColors: THREE.VertexColors,
    color: '#E0FFFF',
    linewidth: 1
  });
  positions = new Float32Array(segments * 3);
  colors = new Float32Array(segments * 3);
  r = 40;
  i = -2000;
  while (i < segments) {
    x = r * Math.cos(i);
    y = r * Math.sin(rnd(i));
    z = r * Math.tan(i);
    positions[i] = x;
    positions[i + 1 * 3] = y;
    positions[i + 2] = z * 0.4;
    colors[i] = Math.floor(Math.random() * 10);
    colors[i + 1] = Math.floor(Math.random() * 10);
    colors[i + 2] = Math.floor(Math.random() * 10);
    x += Math.random();
    y += Math.random();
    z += Math.random();
    r++;
    i++;
  }
  geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
  geometry.computeBoundingSphere();
  mesh = new THREE.Line(geometry, material);
  mesh.geometry.verticesNeedUpdate = true;
  scene.add(mesh);
};

initStats = function() {
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.top = '0px';
  container.appendChild(stats.domElement);
};

onWindowResize = function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
};

animate = function() {
  requestAnimationFrame(animate);
  render();
  stats.update();
};

render = function() {
  var i, j, time;
  time = Date.now() * 0.001;
  for (i = j = 0; j <= 50; i = ++j) {
    mesh.position.x *= time * 0.000025;
    mesh.position.y *= time * 0.00025;
    mesh.position.y *= time * 100.25;
    mesh.rotation.x = time * 0.25;
    mesh.rotation.y = time * 0.4;
    cam_pos(camera, rnd(300), rnd(200), rnd(2000));
    renderer.render(scene, camera);
  }
};

start = function() {
  init();
  initCamera();
  initObject();
  initStats();
  animate();
};

window.addEventListener('resize', onWindowResize, false);

start();

//# sourceMappingURL=ball.js.map
