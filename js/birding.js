// Generated by CoffeeScript 1.9.1
var Boid;

Boid = function() {
  var _acceleration, _avoidWalls, _depth, _goal, _height, _maxSpeed, _maxSteerForce, _neighborhoodRadius, _width, vector;
  vector = new THREE.Vector3();
  _acceleration = void 0;
  _width = 500;
  _height = 500;
  _depth = 700;
  _goal = void 0;
  _neighborhoodRadius = 800;
  _maxSpeed = 6;
  _maxSteerForce = 0.2;
  _avoidWalls = false;
  this.position = new THREE.Vector3();
  this.velocity = new THREE.Vector3();
  _acceleration = new THREE.Vector3();
  this.setGoal = function(target) {
    _goal = target;
  };
  this.setAvoidWalls = function(value) {
    _avoidWalls = value;
  };
  this.setWorldSize = function(width, height, depth) {
    _width = width;
    _height = height;
    _depth = depth;
  };
  this.run = function(boids) {
    if (_avoidWalls) {
      vector.set(-_width, this.position.y, this.position.z);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
      vector.set(_width, this.position.y, this.position.z);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
      vector.set(this.position.x, -_height, this.position.z);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
      vector.set(this.position.x, _height, this.position.z);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
      vector.set(this.position.x, this.position.y, -_depth);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
      vector.set(this.position.x, this.position.y, _depth);
      vector = this.avoid(vector);
      vector.multiplyScalar(5);
      _acceleration.add(vector);
    } else {
      this.checkBounds();
    }
    if (Math.random() > 0.7) {
      this.flock(boids);
    }
    this.move();
  };
  this.flock = function(boids) {
    if (_goal) {
      _acceleration.add(this.reach(_goal, 0.005));
    }
    _acceleration.add(this.alignment(boids));
    _acceleration.add(this.cohesion(boids));
    _acceleration.add(this.separation(boids));
  };
  this.move = function() {
    var l;
    this.velocity.add(_acceleration);
    l = this.velocity.length();
    if (l > _maxSpeed) {
      this.velocity.divideScalar(l / _maxSpeed);
    }
    this.position.add(this.velocity);
    _acceleration.set(0, 0, 0);
  };
  this.checkBounds = function() {
    if (this.position.x > _width) {
      this.position.x = -_width;
    }
    if (this.position.x < -_width) {
      this.position.x = _width;
    }
    if (this.position.y > _height) {
      this.position.y = -_height;
    }
    if (this.position.y < -_height) {
      this.position.y = _height;
    }
    if (this.position.z > _depth) {
      this.position.z = -_depth;
    }
    if (this.position.z < -_depth) {
      this.position.z = _depth;
    }
  };
  this.avoid = function(target) {
    var steer;
    steer = new THREE.Vector3();
    steer.copy(this.position);
    steer.sub(target);
    steer.multiplyScalar(1 / this.position.distanceToSquared(target));
    return steer;
  };
  this.repulse = function(target) {
    var distance, steer;
    distance = this.position.distanceTo(target);
    if (distance < 150) {
      steer = new THREE.Vector3();
      steer.subVectors(this.position, target);
      steer.multiplyScalar(0.5 / distance);
      _acceleration.add(steer);
    }
  };
  this.reach = function(target, amount) {
    var steer;
    steer = new THREE.Vector3();
    steer.subVectors(target, this.position);
    steer.multiplyScalar(amount);
    return steer;
  };
  this.alignment = function(boids) {
    var boid, count, distance, i, il, l, velSum;
    boid = void 0;
    velSum = new THREE.Vector3();
    count = 0;
    i = 0;
    il = boids.length;
    while (i < il) {
      if (Math.random() > 0.6) {
        i++;
        continue;
      }
      boid = boids[i];
      distance = boid.position.distanceTo(this.position);
      if (distance > 0 && distance <= _neighborhoodRadius) {
        velSum.add(boid.velocity);
        count++;
      }
      i++;
    }
    if (count > 0) {
      velSum.divideScalar(count);
      l = velSum.length();
      if (l > _maxSteerForce) {
        velSum.divideScalar(l / _maxSteerForce);
      }
    }
    return velSum;
  };
  this.cohesion = function(boids) {
    var boid, count, distance, i, il, l, posSum, steer;
    boid = void 0;
    distance = void 0;
    posSum = new THREE.Vector3;
    steer = new THREE.Vector3;
    count = 0;
    i = 0;
    il = boids.length;
    while (i < il) {
      if (Math.random() > 0.6) {
        i++;
        continue;
      }
      boid = boids[i];
      distance = boid.position.distanceTo(this.position);
      if (distance > 0 && distance <= _neighborhoodRadius) {
        posSum.add(boid.position);
        count++;
      }
      i++;
    }
    if (count > 0) {
      posSum.divideScalar(count);
    }
    steer.subVectors(posSum, this.position);
    l = steer.length();
    if (l > _maxSteerForce) {
      steer.divideScalar(l / _maxSteerForce);
    }
    return steer;
  };
  this.separation = function(boids) {
    var boid, distance, i, il, posSum, repulse;
    boid = void 0;
    distance = void 0;
    posSum = new THREE.Vector3();
    repulse = new THREE.Vector3();
    i = 0;
    il = boids.length;
    while (i < il) {
      if (Math.random() > 0.6) {
        i++;
        continue;
      }
      boid = boids[i];
      distance = boid.position.distanceTo(this.position);
      if (distance > 0 && distance <= _neighborhoodRadius) {
        repulse.subVectors(this.position, boid.position);
        repulse.normalize();
        repulse.divideScalar(distance);
        posSum.add(repulse);
      }
      i++;
    }
    return posSum;
  };
};

//# sourceMappingURL=birding.js.map
