// Generated by CoffeeScript 1.9.1
var animate, camera, colors, container, effectController, group, initCamera, initGUI, initObj, initStart, initStats, linesMesh, maxParticleCount, onWindowResize, particleCount, particlePositions, particlesData, pointCloud, positions, r, rHalf, render, renderer, scene, starts, stats;

group = void 0;

container = void 0;

stats = void 0;

particlesData = [];

camera = void 0;

scene = void 0;

renderer = void 0;

positions = void 0;

colors = void 0;

pointCloud = void 0;

particlePositions = void 0;

linesMesh = void 0;

maxParticleCount = 1000;

particleCount = 500;

r = 1400;

rHalf = r / 2;

effectController = {
  showDots: true,
  showLines: true,
  minDistance: 300,
  limitConnections: false,
  maxConnections: 100,
  particleCount: 100
};

initGUI = function() {
  var gui;
  gui = new dat.GUI;
  gui.add(effectController, 'showDots').onChange(function(value) {
    pointCloud.visible = value;
  });
  gui.add(effectController, 'showLines').onChange(function(value) {
    linesMesh.visible = value;
  });
  gui.add(effectController, 'minDistance', 10, 1000);
  gui.add(effectController, 'limitConnections');
  gui.add(effectController, 'maxConnections', 0, 1000, 1);
  gui.add(effectController, 'particleCount', 0, maxParticleCount, 1).onChange(function(value) {
    particleCount = parseInt(value);
  });
};

initStart = function() {
  container = document.getElementById('container');
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor('#FA8072', 1.0);
  renderer.gammaInput = true;
  renderer.gammaOutput = true;
  container.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  group = new THREE.Group();
  scene.add(group);
};

initCamera = function() {
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
  cam_pos(camera, rnd(1000), rnd(1000), rnd(1000));
  make_rotate(camera, rnd(700), rnd(700), rnd(700));
  cam_up(camera, rnd(500), rnd(500), rnd(500));
};

initObj = function() {
  var controls, geometry, helper, i, material, pMaterial, particles, segments, x, y, z;
  controls = new THREE.OrbitControls(camera, container);
  controls.userzoom = true;
  helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r * 2, r * 2, r * 2)));
  helper.material.color.setHex('#90EE90');
  helper.material.blending = THREE.AdditiveBlending;
  helper.material.transparent = true;
  group.add(helper);
  segments = maxParticleCount * maxParticleCount;
  positions = new Float32Array(segments * 20);
  colors = new Float32Array(segments * 30);
  pMaterial = new THREE.PointCloudMaterial({
    color: '#00FF00',
    size: 7,
    blending: THREE.AdditiveBlending,
    transparent: true,
    sizeAttenuation: false
  });
  particles = new THREE.BufferGeometry();
  particlePositions = new Float32Array(maxParticleCount * 3);
  i = 0;
  while (i < maxParticleCount) {
    x = Math.random() * r - r / 2;
    y = Math.random() * r - r / 2;
    z = Math.random() * r - r / 2;
    particlePositions[i * rnd(5)] = x;
    particlePositions[i * rnd(3) + 1] = y;
    particlePositions[i * rnd(3) + 2] = z;
    particlesData.push({
      velocity: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 5, -1 + Math.random() * 8),
      numConnections: 1
    });
    i++;
  }
  particles.drawcalls.push({
    start: 0,
    count: particleCount,
    index: 0
  });
  particles.addAttribute('position', new THREE.DynamicBufferAttribute(particlePositions, 3));
  pointCloud = new THREE.PointCloud(particles, pMaterial);
  group.add(pointCloud);
  geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.DynamicBufferAttribute(positions, 3));
  geometry.addAttribute('color', new THREE.DynamicBufferAttribute(colors, 3));
  geometry.computeBoundingSphere();
  geometry.drawcalls.push({
    start: 0,
    count: 0,
    index: 0
  });
  material = new THREE.LineBasicMaterial({
    vertexColors: THREE.VertexColors,
    blending: THREE.AdditiveBlending,
    transparent: true
  });
  linesMesh = new THREE.Line(geometry, material, THREE.LinePieces);
  group.add(linesMesh);
};

initStats = function() {
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.top = '0px';
  container.appendChild(stats.domElement);
};

onWindowResize = function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
};

animate = function() {
  var alpha, colorpos, dist, dx, dy, dz, i, j, numConnected, particleData, particleDataB, vertexpos;
  vertexpos = 0;
  colorpos = 0;
  numConnected = 0;
  i = 0;
  while (i < particleCount) {
    particlesData[i].numConnections = 0;
    i++;
  }
  i = 0;
  while (i < particleCount) {
    particleData = particlesData[i];
    particlePositions[i * 3] += particleData.velocity.x;
    particlePositions[i * 3 + 1] += particleData.velocity.y;
    particlePositions[i * 3 + 2] += particleData.velocity.z;
    if (particlePositions[i * 3 + 1] < -rHalf || particlePositions[i * 3 + 1] > rHalf) {
      particleData.velocity.y = -particleData.velocity.y;
    }
    if (particlePositions[i * 3] < -rHalf || particlePositions[i * 3] > rHalf) {
      particleData.velocity.x = -particleData.velocity.x;
    }
    if (particlePositions[i * 3 + 2] < -rHalf || particlePositions[i * 3 + 2] > rHalf) {
      particleData.velocity.z = -particleData.velocity.z;
    }
    if (effectController.limitConnections && particleData.numConnections >= effectController.maxConnections) {
      i++;
      continue;
    }
    j = i + 1;
    while (j < particleCount) {
      particleDataB = particlesData[j];
      if (effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections) {
        j++;
        continue;
      }
      dx = particlePositions[i * 3] - particlePositions[j * 3];
      dy = particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
      dz = particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
      dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (dist < effectController.minDistance) {
        particleData.numConnections++;
        particleDataB.numConnections++;
        alpha = 1.0 - dist / effectController.minDistance;
        positions[vertexpos++] = particlePositions[i * 3];
        positions[vertexpos++] = particlePositions[i * 3 + 1];
        positions[vertexpos++] = particlePositions[i * 3 + 2];
        positions[vertexpos++] = particlePositions[j * 3];
        positions[vertexpos++] = particlePositions[j * 3 + 1];
        positions[vertexpos++] = particlePositions[j * 3 + 2];
        colors[colorpos++] = alpha;
        colors[colorpos++] = alpha;
        colors[colorpos++] = alpha;
        colors[colorpos++] = alpha;
        colors[colorpos++] = alpha;
        colors[colorpos++] = alpha;
        numConnected++;
      }
      j++;
    }
    i++;
  }
  linesMesh.geometry.drawcalls[0].count = numConnected * 2;
  linesMesh.geometry.attributes.position.needsUpdate = true;
  linesMesh.geometry.attributes.color.needsUpdate = true;
  pointCloud.geometry.attributes.position.needsUpdate = true;
  requestAnimationFrame(animate);
  stats.update();
  render();
};

render = function() {
  var time;
  time = Date.now() * 0.001;
  group.rotation.y = time * 0.1;
  renderer.render(scene, camera);
};

starts = function() {
  initGUI();
  initStart();
  initCamera();
  initObj();
  initStats();
  animate();
};

window.addEventListener('resize', onWindowResize, false);

starts();

//# sourceMappingURL=cube_lines.js.map
