// Generated by CoffeeScript 1.9.1
var adding, animate, baseB, baseG, baseR, camera, direction, foundB, foundG, foundR, geometry, init, initCamera, initOctree, material, mesh, meshCountMax, meshes, meshesSearch, modifyOctree, octree, origin, radius, radiusMax, radiusMaxHalf, radiusSearch, rayCaster, render, renderer, scene, searchMesh, searchOctree, start;

camera = void 0;

scene = void 0;

renderer = void 0;

octree = void 0;

geometry = void 0;

material = void 0;

mesh = void 0;

meshes = [];

meshesSearch = [];

meshCountMax = 1000;

radius = 500;

radiusMax = radius * 200;

radiusMaxHalf = radiusMax * 0.8;

radiusSearch = 400;

searchMesh = void 0;

baseR = 40;

baseG = 100;

baseB = 225;

foundR = 30;

foundG = 100;

foundB = 200;

adding = true;

rayCaster = new THREE.Raycaster();

origin = new THREE.Vector3();

direction = new THREE.Vector3();

init = function() {
  var container;
  container = document.createElement('div');
  scene = new THREE.Scene();
  renderer = new THREE.WebGLRenderer();
  renderer.setClearColor('#2F4F4F');
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(container);
  container.appendChild(renderer.domElement);
};

initCamera = function() {
  camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 1, radius * 10000);
  scene.add(camera);
  cam_pos(camera, rnd(1400), rnd(3000), rnd(5000));
  make_rotate(camera, 1300, 1500, 1400);
};

initOctree = function() {
  octree = new THREE.Octree({
    undeferred: false,
    depthMax: Infinity,
    objectsThreshold: 4,
    overlapPct: 0.45,
    scene: scene
  });
  searchMesh = new THREE.Mesh(new THREE.SphereGeometry(radiusSearch, 10, 10), new THREE.MeshBasicMaterial({
    color: '#7CFC00',
    transparent: true,
    opacity: 0.8
  }));
  scene.add(searchMesh);
};

animate = function() {
  requestAnimationFrame(animate);
  modifyOctree();
  searchOctree();
  render();
  octree.update();
};

modifyOctree = function() {
  if (adding === true) {
    geometry = new THREE.SphereGeometry(40, 10, 10);
    material = new THREE.MeshBasicMaterial();
    material.color.setRGB(baseR, baseG, baseB);
    mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(Math.random() * radiusMax + 1000 - radiusMaxHalf, Math.random() * radiusMax - radiusMaxHalf + 300, Math.random() * radiusMax - radiusMaxHalf + 400);
    octree.add(mesh);
    scene.add(mesh);
    meshes.push(mesh);
    if (meshes.length === meshCountMax) {
      adding = false;
    }
  } else {
    mesh = meshes.shift();
    scene.remove(mesh);
    octree.remove(mesh);
    if (meshes.length === 0) {
      adding = true;
    }
  }
};

searchOctree = function() {
  var i, il, intersections, timeEnd, timeStart;
  i = void 0;
  il = void 0;
  i = 0;
  il = meshesSearch.length;
  while (i < il) {
    meshesSearch[i].object.material.color.setRGB(baseR, baseG, baseB);
    i++;
  }
  searchMesh.position.set(Math.random() * radiusMax - radiusMaxHalf, Math.random() * radiusMax - radiusMaxHalf, Math.random() * radiusMax - radiusMaxHalf);
  timeStart = Date.now();
  origin.copy(searchMesh.position);
  direction.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
  rayCaster.set(origin, direction);
  meshesSearch = octree.search(rayCaster.ray.origin, radiusSearch, true, rayCaster.ray.direction);
  intersections = rayCaster.intersectOctreeObjects(meshesSearch);
  timeEnd = Date.now();
  i = 0;
  il = meshesSearch.length;
  while (i < il) {
    meshesSearch[i].object.material.color.setRGB(foundR, foundG, foundB);
    i++;
  }
};

render = function() {
  var timer;
  timer = -Date.now() / 8000;
  camera.position.x = Math.cos(timer) * 400;
  camera.position.z = Math.cos(timer) * 90000;
  camera.position.y = Math.tan(timer) * 7000;
  camera.lookAt(scene.position);
  renderer.render(scene, camera);
};

start = function() {
  init();
  initCamera();
  initOctree();
  animate();
};

start();

//# sourceMappingURL=octree2.js.map
